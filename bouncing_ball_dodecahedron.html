<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bouncing Ball in Dodecahedron</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.7.0/p5.min.js"></script>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background: #0a0a0a;
            font-family: 'Arial', sans-serif;
        }
        #controls {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border-radius: 10px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        #controls h3 {
            margin: 0 0 10px 0;
            color: #4a9eff;
        }
        #controls label {
            display: block;
            margin: 5px 0;
            font-size: 14px;
        }
        #controls input[type="range"] {
            width: 150px;
            margin-left: 10px;
        }
        #controls input[type="checkbox"] {
            margin-left: 10px;
        }
        #info {
            position: absolute;
            bottom: 10px;
            right: 10px;
            color: white;
            background: rgba(0, 0, 0, 0.7);
            padding: 10px;
            border-radius: 5px;
            font-size: 12px;
            backdrop-filter: blur(10px);
        }
    </style>
</head>
<body>
    <div id="controls">
        <h3>Controls</h3>
        <label>
            Rotation Speed: <input type="range" id="rotSpeed" min="0" max="0.05" step="0.001" value="0.01">
        </label>
        <label>
            Gravity: <input type="range" id="gravity" min="0" max="1" step="0.01" value="0.3">
        </label>
        <label>
            Ball Size: <input type="range" id="ballSize" min="5" max="30" step="1" value="15">
        </label>
        <label>
            Bounce Damping: <input type="range" id="damping" min="0.5" max="1" step="0.01" value="0.85">
        </label>
        <label>
            <input type="checkbox" id="trails" checked> Show Trails
        </label>
        <label>
            <input type="checkbox" id="glow" checked> Glow Effect
        </label>
        <button onclick="resetBall()">Reset Ball</button>
    </div>
    <div id="info">
        Click and drag to rotate view<br>
        Scroll to zoom
    </div>

    <script>
        let dodecahedron;
        let ball;
        let rotationSpeed = 0.01;
        let gravity = 0.3;
        let ballRadius = 15;
        let bounceDamping = 0.85;
        let showTrails = true;
        let showGlow = true;
        let trail = [];
        let zoom = 1;
        let currentRotationX = 0;
        let currentRotationY = 0;

        // Dodecahedron vertices (normalized)
        const phi = (1 + Math.sqrt(5)) / 2; // Golden ratio
        const invPhi = 1 / phi;
        const scale = 150; // Scale factor for the dodecahedron

        class Ball {
            constructor(x, y, z, radius) {
                this.pos = createVector(x, y, z);
                this.vel = createVector(random(-2, 2), random(-2, 2), random(-2, 2));
                this.acc = createVector(0, 0, 0);
                this.radius = radius;
                this.color = color(100, 200, 255);
                this.glowColor = color(150, 220, 255, 100);
            }

            applyForce(force) {
                this.acc.add(force);
            }

            update() {
                // Apply gravity
                this.applyForce(createVector(0, gravity, 0));
                
                // Update physics
                this.vel.add(this.acc);
                this.pos.add(this.vel);
                this.acc.mult(0);
                
                // Add to trail
                if (showTrails && frameCount % 2 === 0) {
                    trail.push({
                        x: this.pos.x,
                        y: this.pos.y,
                        z: this.pos.z,
                        life: 255
                    });
                }
                
                // Limit trail length
                if (trail.length > 50) {
                    trail.shift();
                }
                
                // Update trail
                for (let i = trail.length - 1; i >= 0; i--) {
                    trail[i].life -= 5;
                    if (trail[i].life <= 0) {
                        trail.splice(i, 1);
                    }
                }
            }

            checkCollision(vertices, faces) {
                // First, apply a bounding sphere check as a failsafe
                let maxRadius = scale * 0.85; // Slightly larger than inscribed sphere
                let distFromCenter = this.pos.mag();
                
                if (distFromCenter + this.radius > maxRadius) {
                    // Push back towards center
                    let normal = this.pos.copy();
                    normal.normalize();
                    
                    // Reflect velocity if moving outward
                    let velDotNormal = p5.Vector.dot(this.vel, normal);
                    if (velDotNormal > 0) {
                        this.vel.sub(p5.Vector.mult(normal, 2 * velDotNormal));
                        this.vel.mult(bounceDamping);
                    }
                    
                    // Push ball back inside
                    this.pos.normalize();
                    this.pos.mult(maxRadius - this.radius - 1);
                    return;
                }
                
                // Transform ball position to dodecahedron's local space
                let localPos = this.pos.copy();
                
                // Apply inverse rotations
                // First inverse Y rotation
                let cosY = cos(-currentRotationY);
                let sinY = sin(-currentRotationY);
                let x = localPos.x * cosY + localPos.z * sinY;
                let z = -localPos.x * sinY + localPos.z * cosY;
                localPos.x = x;
                localPos.z = z;
                
                // Then inverse X rotation
                let cosX = cos(-currentRotationX);
                let sinX = sin(-currentRotationX);
                let y = localPos.y * cosX - localPos.z * sinX;
                z = localPos.y * sinX + localPos.z * cosX;
                localPos.y = y;
                localPos.z = z;
                
                // Check each face for collision
                for (let face of faces) {
                    // Calculate face center
                    let center = createVector(0, 0, 0);
                    for (let idx of face) {
                        center.add(vertices[idx]);
                    }
                    center.div(face.length);
                    
                    // Calculate face normal using first three vertices
                    let v0 = vertices[face[0]];
                    let v1 = vertices[face[1]];
                    let v2 = vertices[face[2]];
                    
                    let edge1 = p5.Vector.sub(v1, v0);
                    let edge2 = p5.Vector.sub(v2, v0);
                    let faceNormal = p5.Vector.cross(edge1, edge2);
                    faceNormal.normalize();
                    
                    // Make sure normal points outward
                    if (p5.Vector.dot(faceNormal, center) < 0) {
                        faceNormal.mult(-1);
                    }
                    
                    // Distance from ball center to face plane
                    let distToPlane = p5.Vector.dot(p5.Vector.sub(localPos, v0), faceNormal);
                    
                    // Check if ball is close to this face
                    if (distToPlane > 0 && distToPlane < this.radius + 5) {
                        // Simple check: is the ball center projection near the face center?
                        let projectedPoint = p5.Vector.sub(localPos, p5.Vector.mult(faceNormal, distToPlane));
                        let distToFaceCenter = p5.Vector.dist(projectedPoint, center);
                        
                        // Approximate face size (dodecahedron faces are regular pentagons)
                        let faceRadius = scale * 0.5;
                        
                        if (distToFaceCenter < faceRadius && distToPlane < this.radius) {
                            // Transform normal back to world space
                            let worldNormal = faceNormal.copy();
                            
                            // Apply X rotation
                            y = worldNormal.y * cosX + worldNormal.z * sinX;
                            z = -worldNormal.y * sinX + worldNormal.z * cosX;
                            worldNormal.y = y;
                            worldNormal.z = z;
                            
                            // Apply Y rotation
                            x = worldNormal.x * cosY - worldNormal.z * sinY;
                            z = worldNormal.x * sinY + worldNormal.z * cosY;
                            worldNormal.x = x;
                            worldNormal.z = z;
                            
                            // Check velocity direction
                            let velDotNormal = p5.Vector.dot(this.vel, worldNormal);
                            if (velDotNormal < 0) {
                                // Reflect velocity
                                this.vel.sub(p5.Vector.mult(worldNormal, 2 * velDotNormal));
                                this.vel.mult(bounceDamping);
                                
                                // Push ball away from face
                                let pushDist = this.radius - distToPlane + 1;
                                this.pos.add(p5.Vector.mult(worldNormal, pushDist));
                            }
                        }
                    }
                }
            }

            display() {
                push();
                translate(this.pos.x, this.pos.y, this.pos.z);
                
                // Glow effect
                if (showGlow) {
                    push();
                    noStroke();
                    for (let i = 3; i > 0; i--) {
                        fill(150, 220, 255, 20);
                        sphere(this.radius * (1 + i * 0.3));
                    }
                    pop();
                }
                
                // Main ball
                noStroke();
                ambientMaterial(100, 200, 255);
                sphere(this.radius);
                pop();
            }
        }

        function setup() {
            createCanvas(windowWidth, windowHeight, WEBGL);
            
            // Initialize dodecahedron vertices
            const a = 1;
            const b = invPhi;
            const c = phi;
            
            dodecahedron = {
                vertices: [
                    createVector(a, a, a),
                    createVector(a, a, -a),
                    createVector(a, -a, a),
                    createVector(a, -a, -a),
                    createVector(-a, a, a),
                    createVector(-a, a, -a),
                    createVector(-a, -a, a),
                    createVector(-a, -a, -a),
                    createVector(0, b, c),
                    createVector(0, b, -c),
                    createVector(0, -b, c),
                    createVector(0, -b, -c),
                    createVector(b, c, 0),
                    createVector(b, -c, 0),
                    createVector(-b, c, 0),
                    createVector(-b, -c, 0),
                    createVector(c, 0, b),
                    createVector(c, 0, -b),
                    createVector(-c, 0, b),
                    createVector(-c, 0, -b)
                ],
                faces: [
                    [0, 16, 2, 10, 8],
                    [0, 8, 4, 14, 12],
                    [0, 12, 1, 17, 16],
                    [1, 12, 14, 5, 9],
                    [1, 9, 11, 3, 17],
                    [2, 16, 17, 3, 13],
                    [2, 13, 6, 10],
                    [3, 11, 7, 15, 13],
                    [4, 8, 10, 6, 18],
                    [4, 18, 19, 5, 14],
                    [5, 19, 7, 11, 9],
                    [6, 13, 15, 7, 19, 18]
                ]
            };
            
            // Scale vertices
            for (let v of dodecahedron.vertices) {
                v.mult(scale);
            }
            
            // Initialize ball
            ball = new Ball(0, 0, 0, ballRadius);
            
            // Setup controls
            document.getElementById('rotSpeed').addEventListener('input', (e) => {
                rotationSpeed = parseFloat(e.target.value);
            });
            
            document.getElementById('gravity').addEventListener('input', (e) => {
                gravity = parseFloat(e.target.value);
            });
            
            document.getElementById('ballSize').addEventListener('input', (e) => {
                ballRadius = parseFloat(e.target.value);
                ball.radius = ballRadius;
            });
            
            document.getElementById('damping').addEventListener('input', (e) => {
                bounceDamping = parseFloat(e.target.value);
            });
            
            document.getElementById('trails').addEventListener('change', (e) => {
                showTrails = e.target.checked;
                if (!showTrails) trail = [];
            });
            
            document.getElementById('glow').addEventListener('change', (e) => {
                showGlow = e.target.checked;
            });
        }

        function draw() {
            background(10, 10, 10);
            
            // Camera and lighting
            orbitControl();
            scale(zoom);
            
            // Update rotation angles
            currentRotationY = frameCount * rotationSpeed;
            currentRotationX = frameCount * rotationSpeed * 0.7;
            
            // Lighting
            ambientLight(50);
            directionalLight(255, 255, 255, 0.5, 0.5, -1);
            pointLight(100, 200, 255, ball.pos.x, ball.pos.y, ball.pos.z);
            
            // Update and display ball
            ball.update();
            ball.checkCollision(dodecahedron.vertices, dodecahedron.faces);
            
            // Draw trails
            if (showTrails) {
                strokeWeight(3);
                noFill();
                for (let i = 0; i < trail.length - 1; i++) {
                    let t1 = trail[i];
                    let t2 = trail[i + 1];
                    stroke(100, 200, 255, t1.life);
                    line(t1.x, t1.y, t1.z, t2.x, t2.y, t2.z);
                }
            }
            
            // Display ball
            ball.display();
            
            // Rotate and draw dodecahedron
            push();
            rotateY(currentRotationY);
            rotateX(currentRotationX);
            
            // Draw dodecahedron
            strokeWeight(2);
            stroke(100, 150, 255, 150);
            noFill();
            
            // Draw edges
            let edges = new Set();
            for (let face of dodecahedron.faces) {
                for (let i = 0; i < face.length; i++) {
                    let v1 = face[i];
                    let v2 = face[(i + 1) % face.length];
                    let edge = v1 < v2 ? `${v1}-${v2}` : `${v2}-${v1}`;
                    edges.add(edge);
                }
            }
            
            for (let edge of edges) {
                let [v1, v2] = edge.split('-').map(Number);
                let p1 = dodecahedron.vertices[v1];
                let p2 = dodecahedron.vertices[v2];
                line(p1.x, p1.y, p1.z, p2.x, p2.y, p2.z);
            }
            
            // Draw vertices
            strokeWeight(1);
            fill(150, 200, 255);
            for (let v of dodecahedron.vertices) {
                push();
                translate(v.x, v.y, v.z);
                sphere(3);
                pop();
            }
            pop();
        }

        function mouseWheel(event) {
            zoom *= 1 - event.delta * 0.001;
            zoom = constrain(zoom, 0.1, 3);
            return false;
        }

        function resetBall() {
            ball = new Ball(0, 0, 0, ballRadius);
            trail = [];
        }

        function windowResized() {
            resizeCanvas(windowWidth, windowHeight);
        }
    </script>
</body>
</html>