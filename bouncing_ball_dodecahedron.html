<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bouncing Ball in Dodecahedron</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.7.0/p5.min.js"></script>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background: #0a0a0a;
            font-family: 'Arial', sans-serif;
        }
        #controls {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border-radius: 10px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        #controls h3 {
            margin: 0 0 10px 0;
            color: #4a9eff;
        }
        #controls label {
            display: block;
            margin: 5px 0;
            font-size: 14px;
        }
        #controls input[type="range"] {
            width: 150px;
            margin-left: 10px;
        }
        #controls input[type="checkbox"] {
            margin-left: 10px;
        }
        #info {
            position: absolute;
            bottom: 10px;
            right: 10px;
            color: white;
            background: rgba(0, 0, 0, 0.7);
            padding: 10px;
            border-radius: 5px;
            font-size: 12px;
            backdrop-filter: blur(10px);
        }
    </style>
</head>
<body>
    <div id="controls">
        <h3>Controls</h3>
        <label>
            Rotation Speed: <input type="range" id="rotSpeed" min="0" max="0.05" step="0.001" value="0.01">
        </label>
        <label>
            Gravity: <input type="range" id="gravity" min="0" max="1" step="0.01" value="0.3">
        </label>
        <label>
            Ball Size: <input type="range" id="ballSize" min="5" max="30" step="1" value="15">
        </label>
        <label>
            Bounce Damping: <input type="range" id="damping" min="0.5" max="1" step="0.01" value="0.85">
        </label>
        <label>
            <input type="checkbox" id="trails" checked> Show Trails
        </label>
        <label>
            <input type="checkbox" id="glow" checked> Glow Effect
        </label>
        <button onclick="resetBall()">Reset Ball</button>
    </div>
    <div id="info">
        Click and drag to rotate view<br>
        Scroll to zoom
    </div>

    <script>
        let dodecahedron;
        let ball;
        let rotationSpeed = 0.01;
        let gravity = 0.3;
        let ballRadius = 15;
        let bounceDamping = 0.85;
        let showTrails = true;
        let showGlow = true;
        let trail = [];
        let zoom = 1;

        // Dodecahedron vertices (normalized)
        const phi = (1 + Math.sqrt(5)) / 2; // Golden ratio
        const invPhi = 1 / phi;
        const scale = 150; // Scale factor for the dodecahedron

        class Ball {
            constructor(x, y, z, radius) {
                this.pos = createVector(x, y, z);
                this.vel = createVector(random(-2, 2), random(-2, 2), random(-2, 2));
                this.acc = createVector(0, 0, 0);
                this.radius = radius;
                this.color = color(100, 200, 255);
                this.glowColor = color(150, 220, 255, 100);
            }

            applyForce(force) {
                this.acc.add(force);
            }

            update() {
                // Apply gravity
                this.applyForce(createVector(0, gravity, 0));
                
                // Update physics
                this.vel.add(this.acc);
                this.pos.add(this.vel);
                this.acc.mult(0);
                
                // Add to trail
                if (showTrails && frameCount % 2 === 0) {
                    trail.push({
                        x: this.pos.x,
                        y: this.pos.y,
                        z: this.pos.z,
                        life: 255
                    });
                }
                
                // Limit trail length
                if (trail.length > 50) {
                    trail.shift();
                }
                
                // Update trail
                for (let i = trail.length - 1; i >= 0; i--) {
                    trail[i].life -= 5;
                    if (trail[i].life <= 0) {
                        trail.splice(i, 1);
                    }
                }
            }

            checkCollision(vertices, faces) {
                // Simple sphere collision with dodecahedron using distance from center
                let distFromCenter = this.pos.mag();
                let dodecahedronRadius = scale * 0.85; // Approximate inner radius

                // If ball is outside the dodecahedron, bounce it back
                if (distFromCenter + this.radius > dodecahedronRadius) {
                    // Calculate normal pointing inward
                    let normal = p5.Vector.mult(this.pos, -1);
                    normal.normalize();

                    // Reflect velocity
                    let velDotNormal = p5.Vector.dot(this.vel, normal);
                    if (velDotNormal > 0) {
                        this.vel.sub(p5.Vector.mult(normal, 2 * velDotNormal));
                        this.vel.mult(bounceDamping);

                        // Push ball back inside
                        let pushDistance = (distFromCenter + this.radius) - dodecahedronRadius;
                        this.pos.add(p5.Vector.mult(normal, pushDistance));
                    }
                }

                // Additional precise collision detection for faces
                for (let face of faces) {
                    let faceVertices = face.map(i => vertices[i]);

                    // Calculate face normal (pointing inward)
                    let center = createVector(0, 0, 0);
                    for (let v of faceVertices) {
                        center.add(v);
                    }
                    center.div(faceVertices.length);

                    let v1 = p5.Vector.sub(faceVertices[1], faceVertices[0]);
                    let v2 = p5.Vector.sub(faceVertices[2], faceVertices[0]);
                    let normal = p5.Vector.cross(v1, v2);
                    normal.normalize();

                    // Ensure normal points inward
                    let toCenter = p5.Vector.mult(center, -1);
                    if (p5.Vector.dot(normal, toCenter) < 0) {
                        normal.mult(-1);
                    }

                    // Calculate distance from ball center to face plane
                    let d = p5.Vector.dot(normal, p5.Vector.sub(this.pos, faceVertices[0]));

                    // Check if ball is colliding with this face
                    if (d > 0 && d < this.radius) {
                        // Project ball position onto face plane
                        let projection = p5.Vector.sub(this.pos, p5.Vector.mult(normal, d));

                        // Simple check if projection is near the face
                        let distToFaceCenter = p5.Vector.dist(projection, center);
                        if (distToFaceCenter < 60) { // Approximate face radius
                            // Collision detected - reflect velocity
                            let velDotNormal = p5.Vector.dot(this.vel, normal);
                            if (velDotNormal > 0) {
                                this.vel.sub(p5.Vector.mult(normal, 2 * velDotNormal));
                                this.vel.mult(bounceDamping);

                                // Push ball away from face
                                let pushOut = this.radius - d;
                                this.pos.add(p5.Vector.mult(normal, -pushOut));
                            }
                        }
                    }
                }
            }

            isPointInPolygon(point, polygon, normal) {
                // Simple point-in-polygon test for convex polygons
                let sign = null;
                for (let i = 0; i < polygon.length; i++) {
                    let v1 = polygon[i];
                    let v2 = polygon[(i + 1) % polygon.length];
                    let edge = p5.Vector.sub(v2, v1);
                    let toPoint = p5.Vector.sub(point, v1);
                    let cross = p5.Vector.cross(edge, toPoint);
                    let dotProduct = p5.Vector.dot(cross, normal);
                    
                    if (sign === null) {
                        sign = dotProduct > 0;
                    } else if ((dotProduct > 0) !== sign) {
                        return false;
                    }
                }
                return true;
            }

            display() {
                push();
                translate(this.pos.x, this.pos.y, this.pos.z);
                
                // Glow effect
                if (showGlow) {
                    push();
                    noStroke();
                    for (let i = 3; i > 0; i--) {
                        fill(150, 220, 255, 20);
                        sphere(this.radius * (1 + i * 0.3));
                    }
                    pop();
                }
                
                // Main ball
                noStroke();
                ambientMaterial(100, 200, 255);
                sphere(this.radius);
                pop();
            }
        }

        function setup() {
            createCanvas(windowWidth, windowHeight, WEBGL);
            
            // Initialize dodecahedron vertices
            dodecahedron = {
                vertices: [
                    createVector(a, a, a),
                    createVector(a, a, -a),
                    createVector(a, -a, a),
                    createVector(a, -a, -a),
                    createVector(-a, a, a),
                    createVector(-a, a, -a),
                    createVector(-a, -a, a),
                    createVector(-a, -a, -a),
                    createVector(0, b, c),
                    createVector(0, b, -c),
                    createVector(0, -b, c),
                    createVector(0, -b, -c),
                    createVector(b, c, 0),
                    createVector(b, -c, 0),
                    createVector(-b, c, 0),
                    createVector(-b, -c, 0),
                    createVector(c, 0, b),
                    createVector(c, 0, -b),
                    createVector(-c, 0, b),
                    createVector(-c, 0, -b)
                ],
                faces: [
                    [0, 8, 10, 2, 16],
                    [0, 16, 17, 1, 12],
                    [0, 12, 14, 4, 8],
                    [1, 9, 5, 12, 17],
                    [1, 17, 3, 11, 9],
                    [2, 10, 6, 13, 3],
                    [2, 3, 17, 16],
                    [3, 13, 15, 7, 11],
                    [4, 14, 5, 19, 18],
                    [4, 18, 6, 10, 8],
                    [5, 14, 12, 9],
                    [5, 9, 11, 7, 19],
                    [6, 18, 19, 7, 15],
                    [6, 15, 13]
                ]
            };
            
            // Scale vertices
            for (let v of dodecahedron.vertices) {
                v.mult(150);
            }
            
            // Initialize ball
            ball = new Ball(0, 0, 0, ballRadius);
            
            // Setup controls
            document.getElementById('rotSpeed').addEventListener('input', (e) => {
                rotationSpeed = parseFloat(e.target.value);
            });
            
            document.getElementById('gravity').addEventListener('input', (e) => {
                gravity = parseFloat(e.target.value);
            });
            
            document.getElementById('ballSize').addEventListener('input', (e) => {
                ballRadius = parseFloat(e.target.value);
                ball.radius = ballRadius;
            });
            
            document.getElementById('damping').addEventListener('input', (e) => {
                bounceDamping = parseFloat(e.target.value);
            });
            
            document.getElementById('trails').addEventListener('change', (e) => {
                showTrails = e.target.checked;
                if (!showTrails) trail = [];
            });
            
            document.getElementById('glow').addEventListener('change', (e) => {
                showGlow = e.target.checked;
            });
        }

        function draw() {
            background(10, 10, 10);
            
            // Camera and lighting
            orbitControl();
            scale(zoom);
            
            // Lighting
            ambientLight(50);
            directionalLight(255, 255, 255, 0.5, 0.5, -1);
            pointLight(100, 200, 255, ball.pos.x, ball.pos.y, ball.pos.z);
            
            // Rotate dodecahedron
            rotateY(frameCount * rotationSpeed);
            rotateX(frameCount * rotationSpeed * 0.7);
            
            // Draw trails
            if (showTrails) {
                strokeWeight(3);
                noFill();
                for (let i = 0; i < trail.length - 1; i++) {
                    let t1 = trail[i];
                    let t2 = trail[i + 1];
                    stroke(100, 200, 255, t1.life);
                    line(t1.x, t1.y, t1.z, t2.x, t2.y, t2.z);
                }
            }
            
            // Update and display ball
            ball.update();
            ball.checkCollision(dodecahedron.vertices, dodecahedron.faces);
            ball.display();
            
            // Draw dodecahedron
            strokeWeight(2);
            stroke(100, 150, 255, 150);
            noFill();
            
            // Draw edges
            let edges = new Set();
            for (let face of dodecahedron.faces) {
                for (let i = 0; i < face.length; i++) {
                    let v1 = face[i];
                    let v2 = face[(i + 1) % face.length];
                    let edge = v1 < v2 ? `${v1}-${v2}` : `${v2}-${v1}`;
                    edges.add(edge);
                }
            }
            
            for (let edge of edges) {
                let [v1, v2] = edge.split('-').map(Number);
                let p1 = dodecahedron.vertices[v1];
                let p2 = dodecahedron.vertices[v2];
                line(p1.x, p1.y, p1.z, p2.x, p2.y, p2.z);
            }
            
            // Draw vertices
            strokeWeight(1);
            fill(150, 200, 255);
            for (let v of dodecahedron.vertices) {
                push();
                translate(v.x, v.y, v.z);
                sphere(3);
                pop();
            }
        }

        function mouseWheel(event) {
            zoom *= 1 - event.delta * 0.001;
            zoom = constrain(zoom, 0.1, 3);
            return false;
        }

        function resetBall() {
            ball = new Ball(0, 0, 0, ballRadius);
            trail = [];
        }

        function windowResized() {
            resizeCanvas(windowWidth, windowHeight);
        }
    </script>
</body>
</html>