<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bouncing Ball in Dodecahedron</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.7.0/p5.min.js"></script>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background: #0a0a0a;
            font-family: 'Arial', sans-serif;
        }
        #controls {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border-radius: 10px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        #controls h3 {
            margin: 0 0 10px 0;
            color: #4a9eff;
        }
        #controls label {
            display: block;
            margin: 5px 0;
            font-size: 14px;
        }
        #controls input[type="range"] {
            width: 150px;
            margin-left: 10px;
        }
        #controls input[type="checkbox"] {
            margin-left: 10px;
        }
        #info {
            position: absolute;
            bottom: 10px;
            right: 10px;
            color: white;
            background: rgba(0, 0, 0, 0.7);
            padding: 10px;
            border-radius: 5px;
            font-size: 12px;
            backdrop-filter: blur(10px);
        }
    </style>
</head>
<body>
    <div id="controls">
        <h3>Controls</h3>
        <label>
            Rotation Speed: <input type="range" id="rotSpeed" min="0" max="0.05" step="0.001" value="0.01">
        </label>
        <label>
            Gravity: <input type="range" id="gravity" min="0" max="1" step="0.01" value="0.3">
        </label>
        <label>
            Ball Size: <input type="range" id="ballSize" min="5" max="30" step="1" value="15">
        </label>
        <label>
            Bounce Damping: <input type="range" id="damping" min="0.5" max="1" step="0.01" value="0.85">
        </label>
        <label>
            Wall Bounce Force: <input type="range" id="wallBounce" min="0.8" max="2" step="0.01" value="1.0">
        </label>
        <label>
            <input type="checkbox" id="trails" checked> Show Trails
        </label>
        <label>
            <input type="checkbox" id="glow" checked> Glow Effect
        </label>
        <button onclick="resetBall()">Reset Ball</button>
    </div>
    <div id="info">
        Click and drag to rotate view<br>
        Scroll to zoom
    </div>

    <script>
        let dodecahedron;
        let ball;
        let rotationSpeed = 0.01;
        let gravity = 0.3;
        let ballRadius = 15;
        let bounceDamping = 0.85;
        let wallBounceForce = 1.0;
        let showTrails = true;
        let showGlow = true;
        let trail = [];
        let zoom = 1;
        let currentRotationX = 0;
        let currentRotationY = 0;

        // Dodecahedron vertices (normalized)
        const phi = (1 + Math.sqrt(5)) / 2; // Golden ratio
        const invPhi = 1 / phi;
        const dodecaScale = 150; // Scale factor for the dodecahedron

        class Ball {
            constructor(x, y, z, radius) {
                this.pos = createVector(x, y, z);
                this.vel = createVector(random(-2, 2), random(-2, 2), random(-2, 2));
                this.acc = createVector(0, 0, 0);
                this.radius = radius;
                this.color = color(100, 200, 255);
                this.glowColor = color(150, 220, 255, 100);
            }

            applyForce(force) {
                this.acc.add(force);
            }

            update() {
                // Apply gravity
                this.applyForce(createVector(0, gravity, 0));
                
                // Update physics
                this.vel.add(this.acc);
                this.pos.add(this.vel);
                this.acc.mult(0);
                
                // Add to trail
                if (showTrails && frameCount % 2 === 0) {
                    trail.push({
                        x: this.pos.x,
                        y: this.pos.y,
                        z: this.pos.z,
                        life: 255
                    });
                }
                
                // Limit trail length
                if (trail.length > 50) {
                    trail.shift();
                }
                
                // Update trail
                for (let i = trail.length - 1; i >= 0; i--) {
                    trail[i].life -= 5;
                    if (trail[i].life <= 0) {
                        trail.splice(i, 1);
                    }
                }
            }

            checkCollision(vertices, faces) {
                // Transform vertices to world space based on current rotation
                let worldVertices = [];
                for (let v of vertices) {
                    let worldV = v.copy();
                    
                    // Apply Y rotation
                    let cosY = cos(currentRotationY);
                    let sinY = sin(currentRotationY);
                    let x = worldV.x * cosY - worldV.z * sinY;
                    let z = worldV.x * sinY + worldV.z * cosY;
                    worldV.x = x;
                    worldV.z = z;
                    
                    // Apply X rotation
                    let cosX = cos(currentRotationX);
                    let sinX = sin(currentRotationX);
                    let y = worldV.y * cosX - worldV.z * sinX;
                    z = worldV.y * sinX + worldV.z * cosX;
                    worldV.y = y;
                    worldV.z = z;
                    
                    worldVertices.push(worldV);
                }
                
                // For each face, check if ball is getting too close from inside
                for (let face of faces) {
                    // Get world-space vertices for this face
                    let faceVertices = face.map(idx => worldVertices[idx]);
                    
                    // Calculate face center
                    let faceCenter = createVector(0, 0, 0);
                    for (let v of faceVertices) {
                        faceCenter.add(v);
                    }
                    faceCenter.div(faceVertices.length);
                    
                    // Calculate face normal (pointing inward)
                    let v0 = faceVertices[0];
                    let v1 = faceVertices[1];
                    let v2 = faceVertices[2];
                    
                    let edge1 = p5.Vector.sub(v1, v0);
                    let edge2 = p5.Vector.sub(v2, v0);
                    let normal = p5.Vector.cross(edge1, edge2);
                    normal.normalize();
                    
                    // Ensure normal points inward (toward origin)
                    if (p5.Vector.dot(normal, faceCenter) > 0) {
                        normal.mult(-1);
                    }
                    
                    // Get the plane equation: ax + by + cz + d = 0
                    // where (a,b,c) is the normal and d is the distance
                    let d = -p5.Vector.dot(normal, faceCenter);
                    
                    // Distance from ball center to plane (positive = on the normal side)
                    let distToPlane = p5.Vector.dot(normal, this.pos) + d;
                    
                    // If ball is approaching the face from inside
                    if (distToPlane < this.radius && distToPlane > -this.radius * 2) {
                        // Project ball position onto the face plane
                        let projectedPos = p5.Vector.sub(this.pos, p5.Vector.mult(normal, distToPlane));
                        
                        // Check if the projected position is inside the pentagon
                        let isInsideFace = this.pointInPolygon(projectedPos, faceVertices, normal);
                        
                        if (isInsideFace) {
                            // Ball is colliding with this face
                            if (distToPlane < this.radius) {
                                // Calculate how much we need to push the ball back
                                let penetration = this.radius - distToPlane;
                                
                                // Push ball away from the face (inward)
                                this.pos.add(p5.Vector.mult(normal, penetration + 0.5));
                                
                                // Reflect velocity if moving toward the face
                                let velDotNormal = p5.Vector.dot(this.vel, normal);
                                if (velDotNormal < 0) {
                                    // Reflect velocity with wall bounce force
                                    this.vel.sub(p5.Vector.mult(normal, 2 * velDotNormal));
                                    this.vel.mult(bounceDamping * wallBounceForce);
                                }
                            }
                        }
                    }
                }
            }
            
            pointInPolygon(point, polygon, normal) {
                // Use the crossing number algorithm
                let inside = false;
                let n = polygon.length;
                
                // Find a direction that's not parallel to the normal
                let testDir = createVector(1, 0, 0);
                if (abs(p5.Vector.dot(testDir, normal)) > 0.9) {
                    testDir = createVector(0, 1, 0);
                }
                
                // Make sure test direction is perpendicular to normal
                let cross = p5.Vector.cross(normal, testDir);
                testDir = p5.Vector.cross(cross, normal);
                testDir.normalize();
                
                for (let i = 0; i < n; i++) {
                    let v1 = polygon[i];
                    let v2 = polygon[(i + 1) % n];
                    
                    // Check if edge crosses the test ray from point
                    let edge = p5.Vector.sub(v2, v1);
                    let toV1 = p5.Vector.sub(v1, point);
                    
                    // Calculate intersection using parametric equations
                    let edgeCrossTest = p5.Vector.cross(edge, testDir);
                    let denominator = p5.Vector.dot(edgeCrossTest, normal);
                    
                    if (abs(denominator) > 0.0001) {
                        let t = -p5.Vector.dot(p5.Vector.cross(toV1, testDir), normal) / denominator;
                        let u = -p5.Vector.dot(p5.Vector.cross(toV1, edge), normal) / denominator;
                        
                        if (t >= 0 && t <= 1 && u > 0) {
                            inside = !inside;
                        }
                    }
                }
                
                return inside;
            }

            display() {
                push();
                translate(this.pos.x, this.pos.y, this.pos.z);
                
                // Glow effect
                if (showGlow) {
                    push();
                    noStroke();
                    for (let i = 3; i > 0; i--) {
                        fill(150, 220, 255, 20);
                        sphere(this.radius * (1 + i * 0.3));
                    }
                    pop();
                }
                
                // Main ball
                noStroke();
                ambientMaterial(100, 200, 255);
                sphere(this.radius);
                pop();
            }
        }

        function setup() {
            createCanvas(windowWidth, windowHeight, WEBGL);
            
            // Initialize dodecahedron vertices
            const a = 1.0;
            const b = 1.0 / phi;
            const c = phi;
            
            dodecahedron = {
                vertices: [
                    // (±1, ±1, ±1)
                    createVector(a, a, a),       // 0
                    createVector(a, a, -a),      // 1
                    createVector(a, -a, a),      // 2
                    createVector(a, -a, -a),     // 3
                    createVector(-a, a, a),      // 4
                    createVector(-a, a, -a),     // 5
                    createVector(-a, -a, a),     // 6
                    createVector(-a, -a, -a),    // 7
                    // (0, ±1/φ, ±φ)
                    createVector(0, b, c),       // 8
                    createVector(0, b, -c),      // 9
                    createVector(0, -b, c),      // 10
                    createVector(0, -b, -c),     // 11
                    // (±1/φ, ±φ, 0)
                    createVector(b, c, 0),       // 12
                    createVector(b, -c, 0),      // 13
                    createVector(-b, c, 0),      // 14
                    createVector(-b, -c, 0),     // 15
                    // (±φ, 0, ±1/φ)
                    createVector(c, 0, b),       // 16
                    createVector(c, 0, -b),      // 17
                    createVector(-c, 0, b),      // 18
                    createVector(-c, 0, -b)      // 19
                ],
                faces: [
                    // Top faces
                    [0, 8, 4, 14, 12],
                    [0, 12, 1, 17, 16],
                    [0, 16, 2, 10, 8],
                    [1, 12, 14, 5, 9],
                    [1, 9, 11, 3, 17],
                    // Middle faces
                    [2, 16, 17, 3, 13],
                    [2, 13, 15, 6, 10],
                    [3, 11, 7, 15, 13],
                    // Bottom faces
                    [4, 8, 10, 6, 18],
                    [4, 18, 19, 5, 14],
                    [5, 19, 7, 11, 9],
                    [6, 15, 7, 19, 18]
                ]
            };
            
            // Normalize and scale vertices
            for (let v of dodecahedron.vertices) {
                v.normalize();
                v.mult(dodecaScale);
            }
            
            // Initialize ball at a position inside the dodecahedron
            ball = new Ball(0, -50, 0, ballRadius);
            
            // Setup controls
            document.getElementById('rotSpeed').addEventListener('input', (e) => {
                rotationSpeed = parseFloat(e.target.value);
            });
            
            document.getElementById('gravity').addEventListener('input', (e) => {
                gravity = parseFloat(e.target.value);
            });
            
            document.getElementById('ballSize').addEventListener('input', (e) => {
                ballRadius = parseFloat(e.target.value);
                ball.radius = ballRadius;
            });
            
            document.getElementById('damping').addEventListener('input', (e) => {
                bounceDamping = parseFloat(e.target.value);
            });
            
            document.getElementById('wallBounce').addEventListener('input', (e) => {
                wallBounceForce = parseFloat(e.target.value);
            });
            
            document.getElementById('trails').addEventListener('change', (e) => {
                showTrails = e.target.checked;
                if (!showTrails) trail = [];
            });
            
            document.getElementById('glow').addEventListener('change', (e) => {
                showGlow = e.target.checked;
            });
        }

        function draw() {
            background(10, 10, 10);
            
            // Camera and lighting
            orbitControl();
            scale(zoom);
            
            // Update rotation angles
            currentRotationY = frameCount * rotationSpeed;
            currentRotationX = frameCount * rotationSpeed * 0.7;
            
            // Lighting
            ambientLight(50);
            directionalLight(255, 255, 255, 0.5, 0.5, -1);
            pointLight(100, 200, 255, ball.pos.x, ball.pos.y, ball.pos.z);
            
            // Update and display ball
            ball.update();
            ball.checkCollision(dodecahedron.vertices, dodecahedron.faces);
            
            // Draw trails
            if (showTrails) {
                strokeWeight(3);
                noFill();
                for (let i = 0; i < trail.length - 1; i++) {
                    let t1 = trail[i];
                    let t2 = trail[i + 1];
                    stroke(100, 200, 255, t1.life);
                    line(t1.x, t1.y, t1.z, t2.x, t2.y, t2.z);
                }
            }
            
            // Display ball
            ball.display();
            
            // Rotate and draw dodecahedron
            push();
            rotateY(currentRotationY);
            rotateX(currentRotationX);
            
            // Draw dodecahedron
            strokeWeight(2);
            stroke(100, 150, 255, 150);
            noFill();
            
            // Debug: Highlight faces with different colors
            let faceColors = [
                color(255, 100, 100, 50),
                color(100, 255, 100, 50),
                color(100, 100, 255, 50),
                color(255, 255, 100, 50),
                color(255, 100, 255, 50),
                color(100, 255, 255, 50),
                color(255, 150, 100, 50),
                color(150, 255, 100, 50),
                color(100, 150, 255, 50),
                color(255, 100, 150, 50),
                color(150, 100, 255, 50),
                color(100, 255, 150, 50)
            ];
            
            // Draw filled faces for debugging
            for (let i = 0; i < dodecahedron.faces.length; i++) {
                let face = dodecahedron.faces[i];
                fill(faceColors[i]);
                beginShape();
                for (let idx of face) {
                    let v = dodecahedron.vertices[idx];
                    vertex(v.x, v.y, v.z);
                }
                endShape(CLOSE);
            }
            
            // Draw edges
            stroke(100, 150, 255, 150);
            noFill();
            
            // Draw edges
            let edges = new Set();
            for (let face of dodecahedron.faces) {
                for (let i = 0; i < face.length; i++) {
                    let v1 = face[i];
                    let v2 = face[(i + 1) % face.length];
                    let edge = v1 < v2 ? `${v1}-${v2}` : `${v2}-${v1}`;
                    edges.add(edge);
                }
            }
            
            for (let edge of edges) {
                let [v1, v2] = edge.split('-').map(Number);
                let p1 = dodecahedron.vertices[v1];
                let p2 = dodecahedron.vertices[v2];
                line(p1.x, p1.y, p1.z, p2.x, p2.y, p2.z);
            }
            
            // Draw vertices
            strokeWeight(1);
            fill(150, 200, 255);
            for (let v of dodecahedron.vertices) {
                push();
                translate(v.x, v.y, v.z);
                sphere(3);
                pop();
            }
            pop();
        }

        function mouseWheel(event) {
            zoom *= 1 - event.delta * 0.001;
            zoom = constrain(zoom, 0.1, 3);
            return false;
        }

        function resetBall() {
            ball = new Ball(0, -50, 0, ballRadius);
            trail = [];
        }

        function windowResized() {
            resizeCanvas(windowWidth, windowHeight);
        }
    </script>
</body>
</html>